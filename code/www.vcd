$date
	Tue May  7 00:24:26 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module TestBench $end
$var reg 1 ! CLK $end
$var reg 1 " RST $end
$var reg 32 # instruction [31:0] $end
$var reg 32 $ pc [31:0] $end
$var reg 5 % rd [4:0] $end
$var reg 5 & rs [4:0] $end
$var reg 5 ' rt [4:0] $end
$var integer 32 ( count [31:0] $end
$var integer 32 ) end_count [31:0] $end
$var integer 32 * handle [31:0] $end
$var integer 32 + i [31:0] $end
$var integer 32 , k [31:0] $end
$scope module cpu $end
$var wire 1 ! clk_i $end
$var wire 32 - const_32d4 [31:0] $end
$var wire 1 " rst_n $end
$var wire 1 . select_dst $end
$var wire 32 / zero_out [31:0] $end
$var wire 32 0 sign_out [31:0] $end
$var wire 32 1 shift_result [31:0] $end
$var wire 2 2 select_slt [1:0] $end
$var wire 32 3 rtdata_new [31:0] $end
$var wire 32 4 rtdata [31:0] $end
$var wire 32 5 rsdata [31:0] $end
$var wire 5 6 rdaddr [4:0] $end
$var wire 32 7 pc_out [31:0] $end
$var wire 32 8 pc_in [31:0] $end
$var wire 32 9 instr [31:0] $end
$var wire 1 : en_write $end
$var wire 1 ; alusrc $end
$var wire 3 < aluop [2:0] $end
$var wire 1 = alu_zero $end
$var wire 32 > alu_result [31:0] $end
$var wire 1 ? alu_overflow $end
$var wire 4 @ alu_operation [3:0] $end
$var wire 32 A Result [31:0] $end
$scope module AC $end
$var wire 4 B ALU_operation_o [3:0] $end
$var wire 2 C FURslt_o [1:0] $end
$var wire 6 D funct_i [5:0] $end
$var wire 3 E ALUOp_i [2:0] $end
$var reg 4 F ALU_operation [3:0] $end
$var reg 2 G FURslt [1:0] $end
$upscope $end
$scope module ALU $end
$var wire 4 H ALU_operation_i [3:0] $end
$var wire 1 ? overflow $end
$var wire 1 = zero $end
$var wire 32 I aluSrc2 [31:0] $end
$var wire 32 J aluSrc1 [31:0] $end
$var reg 32 K result [31:0] $end
$upscope $end
$scope module ALU_src2Src $end
$var wire 1 ; select_i $end
$var wire 32 L data_o [31:0] $end
$var wire 32 M data1_i [31:0] $end
$var wire 32 N data0_i [31:0] $end
$upscope $end
$scope module Adder1 $end
$var wire 32 O src2_i [31:0] $end
$var wire 32 P sum_o [31:0] $end
$var wire 32 Q src1_i [31:0] $end
$upscope $end
$scope module Decoder $end
$var wire 3 R ALUOp_o [2:0] $end
$var wire 1 S RegDst $end
$var wire 1 . RegDst_o $end
$var wire 1 : RegWrite_o $end
$var wire 6 T instr_op_i [5:0] $end
$var wire 1 ; ALUSrc_o $end
$var reg 1 U Dst $end
$var reg 3 V op [2:0] $end
$var reg 1 ; src $end
$var reg 1 W write $end
$upscope $end
$scope module IM $end
$var wire 32 X pc_addr_i [31:0] $end
$var reg 32 Y instr_o [31:0] $end
$var integer 32 Z i [31:0] $end
$upscope $end
$scope module Mux_Write_Reg $end
$var wire 5 [ data0_i [4:0] $end
$var wire 5 \ data1_i [4:0] $end
$var wire 1 . select_i $end
$var wire 5 ] data_o [4:0] $end
$upscope $end
$scope module PC $end
$var wire 1 ! clk_i $end
$var wire 32 ^ pc_in_i [31:0] $end
$var wire 1 " rst_n $end
$var reg 32 _ pc_out_o [31:0] $end
$upscope $end
$scope module RDdata_Source $end
$var wire 32 ` data0_i [31:0] $end
$var wire 2 a select_i [1:0] $end
$var wire 32 b data_o [31:0] $end
$var wire 32 c data2_i [31:0] $end
$var wire 32 d data1_i [31:0] $end
$upscope $end
$scope module RF $end
$var wire 5 e RDaddr_i [4:0] $end
$var wire 32 f RDdata_i [31:0] $end
$var wire 5 g RSaddr_i [4:0] $end
$var wire 32 h RSdata_o [31:0] $end
$var wire 5 i RTaddr_i [4:0] $end
$var wire 32 j RTdata_o [31:0] $end
$var wire 1 : RegWrite_i $end
$var wire 1 ! clk_i $end
$var wire 1 " rst_n $end
$upscope $end
$scope module SE $end
$var wire 16 k data_i [15:0] $end
$var wire 32 l data_o [31:0] $end
$upscope $end
$scope module ZF $end
$var wire 16 m data_i [15:0] $end
$var wire 32 n data_o [31:0] $end
$upscope $end
$scope module shifter $end
$var wire 1 o leftRight $end
$var wire 32 p sftSrc [31:0] $end
$var wire 5 q shamt [4:0] $end
$var wire 32 r result [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx r
bx q
bx p
xo
bx0000000000000000 n
bx m
bx l
bx k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx0000000000000000 c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
b100000 Z
bx Y
bx X
xW
bx V
xU
bx T
xS
bx R
bx Q
bx P
b100 O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
x?
bx >
x=
bx <
x;
x:
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx0000000000000000 /
z.
b100 -
b111 ,
b100000 +
b10 *
b11001 )
b0 (
bx '
bx &
bx %
bx $
b0 #
0"
0!
$end
#5000
0?
b0 A
b0 b
b0 f
1=
b0 >
b0 K
b0 `
0o
b1010 1
b1010 d
b1010 r
b0 2
b0 C
b0 G
b0 a
b10 @
b10 B
b10 F
b10 H
0S
0U
1;
b110 <
b110 E
b110 R
b110 V
1:
1W
b1010 3
b1010 I
b1010 L
b1010 p
b0x 6
b0x ]
b0x e
b0 q
b10100000000000000000 /
b10100000000000000000 c
b10100000000000000000 n
b1010 m
b1010 0
b1010 M
b1010 l
b1010 k
b1010 D
b110111 T
b0 4
b0 N
b0 j
b1 i
b0 5
b0 J
b0 h
b0 g
b0 \
b1 [
b11011100000000010000000000001010 9
b11011100000000010000000000001010 Y
b100 8
b100 P
b100 ^
b0 7
b0 Q
b0 X
b0 _
1!
#10000
b1 '
b0 &
b11011100000000010000000000001010 #
b0 ,
b100 $
1"
0!
#15000
b100 A
b100 b
b100 f
b100 1
b100 d
b100 r
0=
b100 >
b100 K
b100 `
b100 3
b100 I
b100 L
b100 p
b0x0 6
b0x0 ]
b0x0 e
b1000000000000000000 /
b1000000000000000000 c
b1000000000000000000 n
b100 m
b100 0
b100 M
b100 l
b100 k
b100 D
b10 i
b10 [
b11011100000000100000000000000100 9
b11011100000000100000000000000100 Y
b1000 8
b1000 P
b1000 ^
b100 7
b100 Q
b100 X
b100 _
1!
#20000
