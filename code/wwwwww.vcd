$date
	Mon May  6 23:05:43 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module TestBench $end
$var reg 1 ! CLK $end
$var reg 1 " RST $end
$var reg 32 # instruction [31:0] $end
$var reg 32 $ pc [31:0] $end
$var reg 5 % rd [4:0] $end
$var reg 5 & rs [4:0] $end
$var reg 5 ' rt [4:0] $end
$var integer 32 ( count [31:0] $end
$var integer 32 ) end_count [31:0] $end
$var integer 32 * handle [31:0] $end
$var integer 32 + i [31:0] $end
$var integer 32 , k [31:0] $end
$scope module cpu $end
$var wire 3 - aluop [2:0] $end
$var wire 1 ! clk_i $end
$var wire 32 . const_32d4 [31:0] $end
$var wire 1 / en_write $end
$var wire 1 " rst_n $end
$var wire 1 0 select_dst $end
$var wire 2 1 select_slt [1:0] $end
$var wire 32 2 zero_out [31:0] $end
$var wire 32 3 sign_out [31:0] $end
$var wire 32 4 shift_result [31:0] $end
$var wire 32 5 rtdata_new [31:0] $end
$var wire 32 6 rtdata [31:0] $end
$var wire 32 7 rsdata [31:0] $end
$var wire 5 8 rdaddr [4:0] $end
$var wire 32 9 pc_out [31:0] $end
$var wire 32 : pc_in [31:0] $end
$var wire 32 ; instr [31:0] $end
$var wire 1 < alusrc $end
$var wire 1 = alu_zero $end
$var wire 32 > alu_result [31:0] $end
$var wire 1 ? alu_overflow $end
$var wire 4 @ alu_operation [3:0] $end
$var wire 32 A Result [31:0] $end
$scope module AC $end
$var wire 3 B ALUOp_i [2:0] $end
$var wire 4 C ALU_operation_o [3:0] $end
$var wire 2 D FURslt_o [1:0] $end
$var wire 6 E funct_i [5:0] $end
$var reg 4 F ALU_operation [3:0] $end
$var reg 2 G FURslt [1:0] $end
$upscope $end
$scope module ALU $end
$var wire 4 H ALU_operation_i [3:0] $end
$var wire 1 ? overflow $end
$var wire 1 = zero $end
$var wire 32 I aluSrc2 [31:0] $end
$var wire 32 J aluSrc1 [31:0] $end
$var reg 32 K result [31:0] $end
$upscope $end
$scope module ALU_src2Src $end
$var wire 1 < select_i $end
$var wire 32 L data_o [31:0] $end
$var wire 32 M data1_i [31:0] $end
$var wire 32 N data0_i [31:0] $end
$upscope $end
$scope module Adder1 $end
$var wire 32 O src2_i [31:0] $end
$var wire 32 P sum_o [31:0] $end
$var wire 32 Q src1_i [31:0] $end
$upscope $end
$scope module Decoder $end
$var wire 3 R ALUOp_o [2:0] $end
$var wire 1 S RegDst $end
$var wire 1 0 RegDst_o $end
$var wire 1 T RegWrite $end
$var wire 1 / RegWrite_o $end
$var wire 6 U instr_op_i [5:0] $end
$var wire 1 V ALU_Op_o $end
$var wire 1 < ALUSrc_o $end
$var reg 1 W Dst $end
$var reg 3 X op [2:0] $end
$var reg 1 < src $end
$var reg 1 Y write $end
$upscope $end
$scope module IM $end
$var wire 32 Z pc_addr_i [31:0] $end
$var reg 32 [ instr_o [31:0] $end
$var integer 32 \ i [31:0] $end
$upscope $end
$scope module Mux_Write_Reg $end
$var wire 5 ] data0_i [4:0] $end
$var wire 5 ^ data1_i [4:0] $end
$var wire 1 0 select_i $end
$var wire 5 _ data_o [4:0] $end
$upscope $end
$scope module PC $end
$var wire 1 ! clk_i $end
$var wire 32 ` pc_in_i [31:0] $end
$var wire 1 " rst_n $end
$var reg 32 a pc_out_o [31:0] $end
$upscope $end
$scope module RDdata_Source $end
$var wire 32 b data0_i [31:0] $end
$var wire 2 c select_i [1:0] $end
$var wire 32 d data_o [31:0] $end
$var wire 32 e data2_i [31:0] $end
$var wire 32 f data1_i [31:0] $end
$upscope $end
$scope module RF $end
$var wire 5 g RDaddr_i [4:0] $end
$var wire 32 h RDdata_i [31:0] $end
$var wire 5 i RSaddr_i [4:0] $end
$var wire 32 j RSdata_o [31:0] $end
$var wire 5 k RTaddr_i [4:0] $end
$var wire 32 l RTdata_o [31:0] $end
$var wire 1 / RegWrite_i $end
$var wire 1 ! clk_i $end
$var wire 1 " rst_n $end
$upscope $end
$scope module SE $end
$var wire 16 m data_i [15:0] $end
$var wire 32 n data_o [31:0] $end
$upscope $end
$scope module ZF $end
$var wire 16 o data_i [15:0] $end
$var wire 32 p data_o [31:0] $end
$upscope $end
$scope module shifter $end
$var wire 1 q leftRight $end
$var wire 32 r sftSrc [31:0] $end
$var wire 5 s shamt [4:0] $end
$var wire 32 t result [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx t
bx s
bx r
xq
bx0000000000000000 p
bx o
bx n
bx m
bx l
bx k
bx j
bx i
bx h
bx g
bx f
bx0000000000000000 e
bx d
bz c
bx b
bx a
bx `
bx _
bx ^
bx ]
b100000 \
bx [
bx Z
xY
bx X
xW
xV
bx U
xT
xS
bz R
bx Q
bx P
b100 O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bz D
bx C
bz B
bx A
bx @
x?
bx >
x=
x<
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx0000000000000000 2
bz 1
z0
z/
b100 .
bz -
b100000 ,
b100000 +
b10 *
b11001 )
b0 (
bx '
bx &
bx %
bx $
b0 #
0"
0!
$end
#5000
0?
b0x0x0000000000000x0x0 A
b0x0x0000000000000x0x0 d
b0x0x0000000000000x0x0 h
1=
b0 >
b0 K
b0 b
0V
b1010 4
b1010 f
b1010 t
0S
0W
1<
b110 X
1T
1Y
b1010 5
b1010 I
b1010 L
b1010 r
b0x 8
b0x _
b0x g
b0 s
b10100000000000000000 2
b10100000000000000000 e
b10100000000000000000 p
b1010 o
b1010 3
b1010 M
b1010 n
b1010 m
b1010 E
b110111 U
b0 6
b0 N
b0 l
b1 k
b0 7
b0 J
b0 j
b0 i
b0 ^
b1 ]
b11011100000000010000000000001010 ;
b11011100000000010000000000001010 [
b100 :
b100 P
b100 `
b0 9
b0 Q
b0 Z
b0 a
1!
#10000
b1 '
b0 &
b11011100000000010000000000001010 #
b0 ,
b100 $
1"
0!
#15000
b100 4
b100 f
b100 t
b0x000000000000000x00 A
b0x000000000000000x00 d
b0x000000000000000x00 h
b100 5
b100 I
b100 L
b100 r
b0x0 8
b0x0 _
b0x0 g
b1000000000000000000 2
b1000000000000000000 e
b1000000000000000000 p
b100 o
b100 3
b100 M
b100 n
b100 m
b100 E
b10 k
b10 ]
b11011100000000100000000000000100 ;
b11011100000000100000000000000100 [
b1000 :
b1000 P
b1000 `
b100 9
b100 Q
b100 Z
b100 a
1!
#20000
